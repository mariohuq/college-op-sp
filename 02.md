# Тема: Основы языка

```c
/* Первая программа */
#include <stdio.h>
int main(){
    printf("Hello world\n"); // > Hello world
}
```

Строка `int main()` должна присутствовать в каждой программе. `()` обозначают, что это — функция. Программа на C может содержать одну или несколько функций. Фигурные скобки `{}` означают начало и конец каждого блока (например, функции). Часть программы между ними называется _блоком_. Команда `printf` отвечает за вывод символов, находящихся в кавычках `""`. _Оператором_ называется строка с командой и `;`. Результат работы оператора — вывод сообщения в кавычках.

Cимвол `\` в строке говорит, что за ним следует escape-последовательность:[^1]

| Символ | Значение |
|--------|----------|
| `\n` | _n_овая строка |
| `\t` | _t_абуляция |
| `\r` | Возв_r_ат каретки |
| `\b` | _b_ackspace |
| `\a` | звуковой сигн_a_л |
| `\"` | собственно `"` |
| `\\` | собственно `\` |

## Типы данных в C

* void
* скалярный
  - арифметические
  - перечисления
  - указатели
* функция
* агрегированный тип
  - массив
  - структура
  - объединение

* основные
  - void char int float double
* производные

### `int`

`short <= int <= long`

Borland: 16/16/32

`unsigned` -- беззнаковый тип

```
not(0110) = 1001 - обратный код
not(0110) + 1 = 1010 - дополнительный код
1010 + 0110 = 0
```

#### Константы

1. `const int n = 10;`
2. `#define N 10`

`0x1F` — 16-ричное
`07` — 8-ричное
`3L` — `long`
`45u` — `unsigned`

### `char`

1 Byte

```
'a' = [31]
"a" = [31][0]
```

### `float`/`double`

Числа с плавающей запятой.

`long double` — 80 разрядов

$$C = M \times 2^P$$

где $$M$$ — мантисса, а $$P$$ — порядок

## Форматированный ввод/вывод (`scanf`, `printf`)

Числа[^2]:

* `%d` — `int`
* `%i` — `int`
* `%f` — `float`
* `%lf` — `double`

$$1.23$$ → `%10.3f` → `_____1.230`.

The format string consists of ordinary multibyte characters (except %), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format: 

* introductory `%` character 
* _(optional)_ one or more _flags_ that modify the behavior of the conversion: 
  - `-`: the result of the conversion is _left-justified_ within the field
    + (by default it is right-justified) 
  - `+`: the _sign_ of signed conversions is always prepended to the result of the conversion
    + (by default the result is preceded by minus only when it is negative) 
  - `space`: if the result of a signed conversion does not start with a sign character, or is empty, space is prepended to the result.
      It is ignored if `+` flag is present. 
  - `#` : alternative form of the conversion is performed.
    + See the table below for exact effects otherwise the behavior is undefined.
  - `0` : for integer and floating point number conversions, _leading zeros_ are used to pad the field instead of space characters.
    + For integer numbers it is ignored if the precision is explicitly specified.
    + For other conversions using this flag results in undefined behavior.
    + It is ignored if `-` flag is present. 
* _(optional)_ `integer value` or `*` that specifies _minimum field width_. The result is padded with space characters (by default), if required, on the left when right-justified, or on the right if left-justified.
  - In the case when `*` is used, the width is specified by an additional argument of type `int`.
  - If the value of the argument is negative, it results with the `-` flag specified and positive field width. (_Note_: This is the minimum width: The value is never truncated.) 
* _(optional)_ `.` followed by integer number or `*`, or neither that specifies precision of the conversion.
  - In the case when `*` is used, the precision is specified by an additional argument of type `int`.
  - If the value of this argument is negative, it is ignored.
  - If neither a number nor `*` is used, the precision is taken as zero.
  - See the table below for exact effects of precision. 
* _(optional)_ _length modifier_ that specifies the size of the argument 
conversion format specifier 

## Пример: Арифметика

```c
#include <stdio.h>
int main() {
    int ai, bi;
    float af, bf;
    double ad, bd;
    scanf_s("%d %d", &ai, &bi);
    printf("%d + %d = %d\n", ai, bi, ai + bi);
    scanf_s("%f %f", &af, &bf);
    printf("%.2f + %.2f = %.2f\n", af, bf, af + bf);
    scanf_s("%lf %lf", &ad, &bd);
    printf("%.2lf + %.2lf = %.2lf\n", ad, bd, ad + bd);
    return 0;
}
```

## Операторы ввода-вывода в C++

```c
 #include <iostream>
cout << "Enter a number";
cin >> a;
cout << "a = " << a << endl;
```

## Оператор `switch`

```c
#include <stdio.h>
int main() {
    int nd = 0; // день недели
    printf("Введите номер дня недели\n");
    scanf("%d",&nd);
    switch (nd){
        case 1: printf("Пн\n"); break;
        case 2: printf("Вт\n"); break;
        case 3: printf("Ср\n"); break;
        case 4: printf("Чт\n"); break;
        case 5: printf("Пт\n"); break;
        case 6: printf("Сб\n"); break;
        case 7: printf("Вс\n"); break;
        default: printf("Нет!\n");
    }
    return 0;
}
```

[^1]: https://en.wikipedia.org/wiki/Escape_sequences_in_C#Table_of_escape_sequences

[^2]: http://en.cppreference.com/w/c/io/fprintf