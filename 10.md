# Тема: Файлы произвольного доступа

## Двоичный файл

Отдельные записи в файле с произвольным доступом обычно имеют фиксированную длину, что позволяет получить к ним непосредственный (значит быстрый) доступ без поиска по всем записям. Поэтому файлы с произвольным доступом используются в системах бронирования мест на самолеты, банковских системах, системах складского учета и других системах обработки транзакций, требующих быстрого доступа к данным.

Существуют другие способы обеспечения произвольного доступа к файлам, но мы ограничим наше обсуждение подходом, использующим записи с фиксированной длиной, ввиду его простоты и наглядности.

Так как все записи файла с произвольным доступом имеют равную длину, можно вычислить точное положение записи относительно начала файла как функцию ключа записи. Вскоре мы увидим, каким образом это помогает получить мгновенный доступ к конкретной записи, даже в случае, когда размер файла очень велик.

Функция `fwrite` пересылает в файл заданное число байт начиная с указанного адреса памяти. Данные записываются с того места в файле, которое обозначено указателем позиции файла.

Условие задачи

> Создать программу для работы со счетами клиентов компании, способную хранить до ста записей с фиксированной длиной. Каждая запись должна состоять из номера счета, который будет использоваться как ключ, имени, фамилии и сальдо. В программе должны быть предусмотрены возможности: обновлять счета, вставлять записи с новыми счетами, удалять счет и выводить список всех записей со счетами в отформатированном виде, пригодном для печати, в текстовый файл. Использовать для работы файл с произвольным доступом.[^1]

| № счета | Фамилия | Имя  | Сальдо|
|--------|---------|------|-------|
| 1      | Фамилиев | Имен | 233   |

```c
int blank() 
{
    int i;
    FILE *cfPtr;
    struct clientData blankClient = { 0,"","",0.0 };

    fopen_s(&cfPtr, "credit.dat", "wb");

    for (i = 0; i < 100; i++)
        fwrite(&blankClient, sizeof(clientData), 1, cfPtr);

    fclose(cfPtr);
    printf("Created credit.dat");
    return 0;   
}
```

В нашей программе в результате выполнения оператора `fwrite(sblankClient, sizeof(struct clientData) , 1, cfPtr);` структура `blankClient` размером `sizeof(struct clientData)` будет записана в файл, указанный `cfPtr`. Операция `sizeof` возвращает размер в байтах для объекта, содержащегося в скобках (в данном случае — это `struct clientData`). Операция `sizeof` является исполняемой во время компиляции одноместной операцией, возвращающей целое число без знака.

Операция `sizeof` может использоваться для определения размера в байтах для любого типа данных или выражения. К примеру, `sizeof(int)` используется для того, чтобы определить, хранится целое в двух или в четырех байтах для данного конкретного компьютера.

## Произвольная запись в файл произвольного доступа

Программа записывает данные в файл `credit.dat`. Для хранения данных в специально определенных местах файла используется комбинация `fseek` и `fwrite`. Функция `fseek` устанавливает указатель позиции файла в заданное положение, после чего `fwrite` записывает данные.

```c
int enter() {
    FILE *cfPtr;
    struct clientData client;
    fopen_s(&cfPtr, "credit.dat", "r+");
    printf("Enter account number (1 to 100, 0 to end input)\n> ");
    scanf_s("%d", &client.acctNum);
    while ((client.acctNum > 0) & (client.acctNum <= 100)) {
        printf("Enter lastname, firstname, balance\n> ");
        scanf_s("%s%s%f", client.lastName, (rsize_t)sizeof client.lastName, &client.firstName, (rsize_t)sizeof client.firstName, &client.balance);
        fseek(cfPtr, (client.acctNum - 1) * sizeof(clientData), SEEK_SET);
        fwrite(&client, sizeof(struct clientData), 1, cfPtr);
        printf("Enter account number\n> ");
        scanf_s("%d", &client.acctNum);
    }
    fclose(cfPtr);
    return(0);
}
```

Оператор

    fseek(cfPtr, (accountNum -1) * sizeof(struct clientData), SEEK_SET);

устанавливает указатель позиции файла, на который ссылается `cfPtr` на байт, определяемый выражением `(accountNum-l)*sizeof(struct clientData);` значение этого выражения называется смещением. Поскольку номер счета — число от 1 до 100, а байты в файле начинаются с нулевого, то при нахождении положения байта из номера счета вычитается 1. Таким образом, для первой записи указатель позиции файла устанавливается на байт 0 файла. Символическая константа
`SEEK_SET` показывает, что указатель позиции файла устанавливается относительно начала файла на величину смещения. Рассмотрение приведенного выше оператора показывает, что поиск в файле счета с номером 1 устанавливает указатель позиции файла на начало файла, поскольку вычисленное значение равно 0. Указатель позиции файла показывает, что следующий байт, который будет считан или записан, это пятый байт от начала файла.

Согласно стандарту ANSI прототип функции `fseek` определяется как

    int fseek(FILE *stream, long int offset, int whence);

где `offset` — число байт от положения, задаваемого `whence`, в файле, на который указывает `stream`. Аргумент whence может иметь одно из трех значений — `SEEK_SET`, `SEEK_CUR` или `SEEK_END`, — указывающих место в файле, с которого начинается поиск. `SEEK_SET` указывает, что поиск начнется с начала файла; `SEEK_CUR` указывает, что поиск начнется с текущего положения в файле; и наконец, `SEEK_END` указывает, что поиск начнется с конца файла. Эти три символические константы определены в заголовочном файле `stdio.h`.

## Последовательное чтение данных из файла произвольного доступа

Функция `fread` считывает заданное число байт из файла в память. Например, оператор

`fread(Sclient, sizeof(struct clientData), 1, cfPtr);`

считывает число байтов, равное `sizeof(struct clientData)`, из файла, на который ссылается `cfPtr`, и сохраняет данные в структуре `client`. Байты считываются из файла начиная с места, определенного указателем позиции файла. Функцию `fread` можно использовать и для чтения нескольких элементов массива с фиксированным размером с помощью указателя на массив, в котором будут храниться элементы, и указанием числа элементов, которые необходимо прочитать. Представленный выше оператор определяет, что должен быть прочитан один элемент. Для того чтобы прочитать более одного элемента, необходимо задать соответствующее значение в третьем аргументе функции `fread`.

Программа считывает последовательно каждую запись из файла
`"credit.dat"`, проверяет все записи на наличие данных и распечатывает содержащие данные записи в форматированном виде. Функция `feof` отслеживает момент, когда достигается конец файла, а функция `fread` передает данные с диска в структуру `client` типа `clientData`.

```c
int print() {
    FILE *cfPtr;
    struct clientData client;
    fopen_s(&cfPtr, "credit.dat", "r");
    printf("%-4s | %-15s | %-10s | %10s\n", "Acct", "Last Name", "First Name", "Balance");
    printf("-----|-----------------|------------|-----------\n");
    while (!feof(cfPtr)) {
        fread(&client, sizeof(clientData), 1, cfPtr);
        if ((client.acctNum > 0) & (client.acctNum <= 100))
            printf("%-4d | %-15s | %-10s | %10.2f\n",
                client.acctNum,
                client.lastName,
                client.firstName,
                client.balance);
    }
    printf("-----|-----------------|------------|-----------\n");
    fclose(cfPtr);
    return(0);
}
```

## Пример: программа обработки транзакций

Следующая программа предназначена для работы с банковскими счетами. Программа позволяет обновлять существующие счета, добавлять новые, уничтожать счета и сохранять список всех текущих счетов в файле текстового формата для вывода на печать. Предполагается, что была выполнена программа, создающая файл
`credit.dat`.

[^1]: Х. М. Дейтел, П. Дж. Дейтел - Как программировать на С, с. 503